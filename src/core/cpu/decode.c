/*
 * Copyright 2025 Nuo Shen, Nanjing University
 *
 * This file is part of the UEMU project.
 *
 * The majority of this file is developed by Nuo Shen under the Apache License,
 * Version 2.0. However, certain portions of this file are adapted from the NEMU
 * project (Copyright (c) 2014-2024 Zihao Yu, Nanjing University), which is
 * licensed under the Mulan PSL v2.
 *
 * Therefore, this file as a whole is distributed under both licenses:
 *   - Apache License 2.0 for the original portions by Nuo Shen
 *   - Mulan PSL v2 for the adapted portions from NEMU
 *
 * You may obtain copies of both licenses at:
 *   - Apache License 2.0: http://www.apache.org/licenses/LICENSE-2.0
 *   - Mulan PSL v2:      http://license.coscl.org.cn/MulanPSL2
 *
 * When redistributing this file or a derived work, you must comply with
 * both licenses accordingly.
 */

#include "core/cpu/decode.h"
#include "core/riscv.h"

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

#define R(i) rv.X[i]
#define F(i) rv.F[i]

typedef enum {
    // 32 bit
    TYPE_I,
    TYPE_U,
    TYPE_S,
    TYPE_J,
    TYPE_R,
    TYPE_B,
    TYPE_R4,

    // 16 bit
    TYPE_CR,
    TYPE_CI,
    TYPE_CSS,
    TYPE_CIW,
    TYPE_CL,
    TYPE_CS,
    TYPE_CA,
    TYPE_CB,
    TYPE_CJ,

    TYPE_N, // none
} inst_type_t;

#define REG_C(x) ((x) + 8)

#define immI()                                                                 \
    do {                                                                       \
        *imm = SEXT(BITS(i, 31, 20), 12);                                      \
    } while (0)
#define immU()                                                                 \
    do {                                                                       \
        *imm = SEXT(BITS(i, 31, 12), 20) << 12;                                \
    } while (0)
#define immS()                                                                 \
    do {                                                                       \
        *imm = (SEXT(BITS(i, 31, 25), 7) << 5) | BITS(i, 11, 7);               \
    } while (0)
#define immJ()                                                                 \
    do {                                                                       \
        *imm = SEXT(BITS(i, 31, 31) << 20 | BITS(i, 19, 12) << 12 |            \
                        BITS(i, 20, 20) << 11 | BITS(i, 30, 21) << 1,          \
                    21);                                                       \
    } while (0)
#define immB()                                                                 \
    do {                                                                       \
        *imm = SEXT(BITS(i, 31, 31) << 12 | BITS(i, 7, 7) << 11 |              \
                        BITS(i, 30, 25) << 5 | BITS(i, 11, 8) << 1,            \
                    13);                                                       \
    } while (0)
#define immCI()                                                                \
    do {                                                                       \
        *imm = SEXT(BITS(i, 12, 12) << 5 | BITS(i, 6, 2), 6);                  \
    } while (0)
#define immCIW()                                                               \
    do {                                                                       \
        *imm = BITS(i, 10, 7) << 6 | BITS(i, 12, 11) << 4 |                    \
               BITS(i, 5, 5) << 3 | BITS(i, 6, 6) << 2;                        \
    } while (0)
#define immCB()                                                                \
    do {                                                                       \
        *imm = SEXT(BITS(i, 12, 12) << 8 | BITS(i, 6, 5) << 6 |                \
                        BITS(i, 2, 2) << 5 | BITS(i, 11, 10) << 3 |            \
                        BITS(i, 4, 3) << 1,                                    \
                    9);                                                        \
    } while (0)
#define immCJ()                                                                \
    do {                                                                       \
        *imm = SEXT(BITS(i, 12, 12) << 11 | BITS(i, 11, 11) << 4 |             \
                        BITS(i, 10, 9) << 8 | BITS(i, 8, 8) << 10 |            \
                        BITS(i, 7, 7) << 6 | BITS(i, 6, 6) << 7 |              \
                        BITS(i, 5, 3) << 1 | BITS(i, 2, 2) << 5,               \
                    12);                                                       \
    } while (0)
#define immCIU()                                                               \
    do {                                                                       \
        *imm = (BITS(i, 12, 12) << 5) | BITS(i, 6, 2);                         \
    } while (0)
#define immCLWSP()                                                             \
    do {                                                                       \
        *imm = BITS(i, 3, 2) << 6 | BITS(i, 12, 12) << 5 | BITS(i, 6, 4) << 2; \
    } while (0)
#define immCLDSP()                                                             \
    do {                                                                       \
        *imm = BITS(i, 4, 2) << 6 | BITS(i, 12, 12) << 5 | BITS(i, 6, 5) << 3; \
    } while (0)
#define immCSWSP()                                                             \
    do {                                                                       \
        *imm = BITS(i, 8, 7) << 6 | BITS(i, 12, 9) << 2;                       \
    } while (0)
#define immCSDSP()                                                             \
    do {                                                                       \
        *imm = BITS(i, 9, 7) << 6 | BITS(i, 12, 10) << 3;                      \
    } while (0)
#define immCLUI()                                                              \
    do {                                                                       \
        *imm = SEXT(BITS(i, 12, 12) << 17 | BITS(i, 6, 2) << 12, 18);          \
    } while (0)
#define immCADDI16SP()                                                         \
    do {                                                                       \
        *imm = SEXT(BITS(i, 12, 12) << 9 | BITS(i, 4, 3) << 7 |                \
                        BITS(i, 5, 5) << 6 | BITS(i, 2, 2) << 5 |              \
                        BITS(i, 6, 6) << 4,                                    \
                    10);                                                       \
    } while (0)
#define immCLW() /* c.lw */                                                    \
    do {                                                                       \
        *imm = (BITS(i, 5, 5) << 6) | (BITS(i, 12, 10) << 3) |                 \
               (BITS(i, 6, 6) << 2);                                           \
    } while (0)
#define immCLD() /* c.fld, c.ld */                                             \
    do {                                                                       \
        *imm = (BITS(i, 6, 5) << 6) | (BITS(i, 12, 10) << 3);                  \
    } while (0)
#define immCSW() /* c.sw */                                                    \
    do {                                                                       \
        *imm = (BITS(i, 5, 5) << 6) | (BITS(i, 12, 10) << 3) |                 \
               (BITS(i, 6, 6) << 2);                                           \
    } while (0)
#define immCSD() /* c.sd, c.fsd */                                             \
    do {                                                                       \
        *imm = (BITS(i, 6, 5) << 6) | (BITS(i, 12, 10) << 3);                  \
    } while (0)
#define immCBS() /* c.srli, c.srai, c.andi */                                  \
    do {                                                                       \
        uint32_t raw = (BITS(i, 12, 12) << 5) | BITS(i, 6, 2);                 \
        if (BITS(i, 11, 10) == 0b10)                                           \
            *imm = SEXT(raw, 6);                                               \
        else                                                                   \
            *imm = raw;                                                        \
    } while (0)

FORCE_INLINE void decode_operand_32(rv_insn_t *s, int *rd, int *rs1, int *rs2,
                                    int *rs3, uint64_t *imm, inst_type_t type) {
    uint32_t i = s->inst;
    *rs1 = BITS(i, 19, 15);
    *rs2 = BITS(i, 24, 20);
    *rs3 = BITS(i, 31, 27);
    *rd = BITS(i, 11, 7);
    switch (type) {
        case TYPE_I: immI(); break;
        case TYPE_U: immU(); break;
        case TYPE_S: immS(); break;
        case TYPE_N: break;
        case TYPE_J: immJ(); break;
        case TYPE_R: break;
        case TYPE_B: immB(); break;
        case TYPE_R4: break;
        default: __UNREACHABLE;
    }
}

FORCE_INLINE void decode_operand_16(rv_insn_t *s, int *rd, int *rs1, int *rs2,
                                    uint64_t *imm, inst_type_t type) {
    uint16_t i = s->inst & 0xffff;
    uint8_t funct3;
    uint8_t opcode;
    switch (type) {
        case TYPE_CR:
            *rd = BITS(i, 11, 7);
            *rs1 = BITS(i, 11, 7);
            *rs2 = BITS(i, 6, 2);
            break;
        case TYPE_CI:
            *rs1 = *rd = BITS(i, 11, 7);
            funct3 = BITS(i, 15, 13);
            opcode = BITS(i, 1, 0);
            if (opcode == 0b01) {
                if (funct3 ==
                    0b000) { /* C.ADDI (or C.NOP if rd==0 && imm==0) */
                    immCI();
                } else if (funct3 == 0b001) { /* C.ADDIW */
                    immCI();
                } else if (funct3 == 0b010) { /* C.LI */
                    immCI();
                } else if (funct3 == 0b011) {
                    if (*rd == 2) {
                        immCADDI16SP(); /* C.ADDI16SP */
                    } else if (*rd != 0) {
                        immCLUI(); /* C.LUI for rd != 0,2 */
                    } else {
                        immCI();
                    }
                } else {
                    immCI();
                }
            } else if (opcode == 0b10) {
                if (funct3 == 0b000) { /* C.SLLI */
                    immCIU();
                } else if (funct3 == 0b010) { /* C.LWSP */
                    immCLWSP();
                } else if (funct3 == 0b011 ||
                           funct3 == 0b001) { /* C.LDSP C.FLDSP */
                    immCLDSP();
                } else {
                    immCI();
                }
            } else {
                immCI();
            }
            break;
        case TYPE_CSS:
            *rs1 = 2; // sp
            *rs2 = BITS(i, 6, 2);
            funct3 = BITS(i, 15, 13);
            if (funct3 == 0b110) { // C.SWSP
                immCSWSP();
            } else if (funct3 == 0b111 || funct3 == 0b101) { // C.SDSP C.FSDSP
                immCSDSP();
            }
            break;
        case TYPE_CIW:
            *rd = REG_C(BITS(i, 4, 2));
            *rs1 = 2; // sp
            immCIW();
            break;
        case TYPE_CL:
            *rd = REG_C(BITS(i, 4, 2));
            *rs1 = REG_C(BITS(i, 9, 7));
            funct3 = BITS(i, 15, 13);
            if (funct3 == 0b010) {
                immCLW();
            } else if (funct3 == 0b001 || funct3 == 0b011) {
                immCLD();
            } else {
                __UNREACHABLE;
            }
            break;
        case TYPE_CS:
            *rs1 = REG_C(BITS(i, 9, 7));
            *rs2 = REG_C(BITS(i, 4, 2));
            funct3 = BITS(i, 15, 13);
            if (funct3 == 0b110) {
                immCSW();
            } else if (funct3 == 0b101 || funct3 == 0b111) {
                immCSD();
            } else {
                __UNREACHABLE;
            }
            break;
        case TYPE_CA:
            *rd = REG_C(BITS(i, 9, 7));
            *rs1 = REG_C(BITS(i, 9, 7));
            *rs2 = REG_C(BITS(i, 4, 2));
            break;
        case TYPE_CB:
            *rd = *rs1 = REG_C(BITS(i, 9, 7));
            funct3 = BITS(i, 15, 13);
            if (funct3 == 0b100)
                immCBS();
            else
                immCB();
            break;
        case TYPE_CJ: immCJ(); break;
        case TYPE_N: break;
        default: __UNREACHABLE;
    }
}

#define INSTPAT_INST(s) ((s)->inst)

#define INSTPAT_MATCH(s, name, type)                                           \
    {                                                                          \
        int rd = 0, rs1 = 0, rs2 = 0, rs3 = 0;                                 \
        uint64_t imm = 0;                                                      \
        decode_operand_32(s, &rd, &rs1, &rs2, &rs3, &imm,                      \
                          concat(TYPE_, type));                                \
        (s)->rd = rd;                                                          \
        (s)->rs1 = rs1;                                                        \
        (s)->rs2 = rs2;                                                        \
        (s)->rs3 = rs3;                                                        \
        (s)->imm = imm;                                                        \
        (s)->exec = exec_##name;                                               \
    }

void cpu_decode_32(rv_insn_t *s) {
    INSTPAT_START();

    // RV64I instructions
    INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add, R);
    INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I);
    INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw, I);
    INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw, R);
    INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and, R);
    INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi, I);
    INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U);
    INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq, B);
    INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge, B);
    INSTPAT("??????? ????? ????? 111 ????? 11000 11", bgeu, B);
    INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt, B);
    INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu, B);
    INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne, B);
    INSTPAT("0000??? ????? 00000 000 00000 00011 11", fence, I);
    INSTPAT("0000000 00000 00000 001 00000 00011 11", fence_i, I);
    INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J);
    INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr, I);
    INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb, I);
    INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu, I);
    INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld, I);
    INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh, I);
    INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu, I);
    INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui, U);
    INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw, I);
    INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu, I);
    INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or, R);
    INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori, I);
    INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb, S);
    INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd, S);
    INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh, S);
    INSTPAT("0000000 ????? ????? 001 ????? 01100 11", sll, R);
    INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli, I);
    INSTPAT("0000000 ????? ????? 001 ????? 00110 11", slliw, I);
    INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw, R);
    INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt, R);
    INSTPAT("??????? ????? ????? 010 ????? 00100 11", slti, I);
    INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu, I);
    INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu, R);
    INSTPAT("0100000 ????? ????? 101 ????? 01100 11", sra, R);
    INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai, I);
    INSTPAT("0100000 ????? ????? 101 ????? 00110 11", sraiw, I);
    INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw, R);
    INSTPAT("0000000 ????? ????? 101 ????? 01100 11", srl, R);
    INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli, I);
    INSTPAT("0000000 ????? ????? 101 ????? 00110 11", srliw, I);
    INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub, R);
    INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw, R);
    INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S);
    INSTPAT("0000000 ????? ????? 100 ????? 01100 11", xor, R);
    INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori, I);
    INSTPAT("??????? ????? ????? 011 ????? 11100 11", csrrc, I);
    INSTPAT("??????? ????? ????? 111 ????? 11100 11", csrrci, I);
    INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs, I);
    INSTPAT("??????? ????? ????? 110 ????? 11100 11", csrrsi, I);
    INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw, I);
    INSTPAT("??????? ????? ????? 101 ????? 11100 11", csrrwi, I);
    INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak, N);
    INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall, N);
    INSTPAT("0011000 00010 00000 000 00000 11100 11", mret, N);
    INSTPAT("0001001 ????? ????? 000 00000 11100 11", sfence_vma, R);
    INSTPAT("0001000 00010 00000 000 00000 11100 11", sret, N);
    INSTPAT("0001000 00101 00000 000 00000 11100 11", wfi, N);

    // RV64M instructions
    INSTPAT("0000001 ????? ????? 100 ????? 01100 11", div, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01100 11", divu, R);
    INSTPAT("0000001 ????? ????? 101 ????? 01110 11", divuw, R);
    INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul, R);
    INSTPAT("0000001 ????? ????? 001 ????? 01100 11", mulh, R);
    INSTPAT("0000001 ????? ????? 010 ????? 01100 11", mulhsu, R);
    INSTPAT("0000001 ????? ????? 011 ????? 01100 11", mulhu, R);
    INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01100 11", rem, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01100 11", remu, R);
    INSTPAT("0000001 ????? ????? 111 ????? 01110 11", remuw, R);
    INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw, R);

    // RV64A instructions
    INSTPAT("00010?? 00000 ????? 011 ????? 01011 11", lr_d, R);
    INSTPAT("00010?? 00000 ????? 010 ????? 01011 11", lr_w, R);
    INSTPAT("00011?? ????? ????? 011 ????? 01011 11", sc_d, R);
    INSTPAT("00011?? ????? ????? 010 ????? 01011 11", sc_w, R);
    INSTPAT("00000?? ????? ????? 011 ????? 01011 11", amoadd_d, R);
    INSTPAT("00000?? ????? ????? 010 ????? 01011 11", amoadd_w, R);
    INSTPAT("01100?? ????? ????? 011 ????? 01011 11", amoand_d, R);
    INSTPAT("01100?? ????? ????? 010 ????? 01011 11", amoand_w, R);
    INSTPAT("01000?? ????? ????? 011 ????? 01011 11", amoor_d, R);
    INSTPAT("01000?? ????? ????? 010 ????? 01011 11", amoor_w, R);
    INSTPAT("00100?? ????? ????? 011 ????? 01011 11", amoxor_d, R);
    INSTPAT("00100?? ????? ????? 010 ????? 01011 11", amoxor_w, R);
    INSTPAT("10100?? ????? ????? 011 ????? 01011 11", amomax_d, R);
    INSTPAT("10100?? ????? ????? 010 ????? 01011 11", amomax_w, R);
    INSTPAT("11100?? ????? ????? 011 ????? 01011 11", amomaxu_d, R);
    INSTPAT("11100?? ????? ????? 010 ????? 01011 11", amomaxu_w, R);
    INSTPAT("10000?? ????? ????? 011 ????? 01011 11", amomin_d, R);
    INSTPAT("10000?? ????? ????? 010 ????? 01011 11", amomin_w, R);
    INSTPAT("11000?? ????? ????? 011 ????? 01011 11", amominu_d, R);
    INSTPAT("11000?? ????? ????? 010 ????? 01011 11", amominu_w, R);
    INSTPAT("00001?? ????? ????? 011 ????? 01011 11", amoswap_d, R);
    INSTPAT("00001?? ????? ????? 010 ????? 01011 11", amoswap_w, R);

    // RV64F instructions
    INSTPAT("??????? ????? ????? 010 ????? 00001 11", flw, I);
    INSTPAT("??????? ????? ????? 010 ????? 01001 11", fsw, S);
    INSTPAT("0000000 ????? ????? ??? ????? 10100 11", fadd_s, R);
    INSTPAT("0000100 ????? ????? ??? ????? 10100 11", fsub_s, R);
    INSTPAT("0001000 ????? ????? ??? ????? 10100 11", fmul_s, R);
    INSTPAT("0001100 ????? ????? ??? ????? 10100 11", fdiv_s, R);
    INSTPAT("0101100 00000 ????? ??? ????? 10100 11", fsqrt_s, R);
    INSTPAT("0010000 ????? ????? 000 ????? 10100 11", fsgnj_s, R);
    INSTPAT("0010000 ????? ????? 001 ????? 10100 11", fsgnjn_s, R);
    INSTPAT("0010000 ????? ????? 010 ????? 10100 11", fsgnjx_s, R);
    INSTPAT("0010100 ????? ????? 000 ????? 10100 11", fmin_s, R);
    INSTPAT("0010100 ????? ????? 001 ????? 10100 11", fmax_s, R);
    INSTPAT("1100000 00000 ????? ??? ????? 10100 11", fcvt_w_s, R);
    INSTPAT("1100000 00001 ????? ??? ????? 10100 11", fcvt_wu_s, R);
    INSTPAT("1100000 00010 ????? ??? ????? 10100 11", fcvt_l_s, R);
    INSTPAT("1100000 00011 ????? ??? ????? 10100 11", fcvt_lu_s, R);
    INSTPAT("1101000 00000 ????? ??? ????? 10100 11", fcvt_s_w, R);
    INSTPAT("1101000 00001 ????? ??? ????? 10100 11", fcvt_s_wu, R);
    INSTPAT("1101000 00010 ????? ??? ????? 10100 11", fcvt_s_l, R);
    INSTPAT("1101000 00011 ????? ??? ????? 10100 11", fcvt_s_lu, R);
    INSTPAT("1110000 00000 ????? 000 ????? 10100 11", fmv_x_w, R);
    INSTPAT("1111000 00000 ????? 000 ????? 10100 11", fmv_w_x, R);
    INSTPAT("1110000 00000 ????? 001 ????? 10100 11", fclass_s, R);
    INSTPAT("1010000 ????? ????? 010 ????? 10100 11", feq_s, R);
    INSTPAT("1010000 ????? ????? 001 ????? 10100 11", flt_s, R);
    INSTPAT("1010000 ????? ????? 000 ????? 10100 11", fle_s, R);
    INSTPAT("?????00 ????? ????? ??? ????? 10000 11", fmadd_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10001 11", fmsub_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10010 11", fnmsub_s, R4);
    INSTPAT("?????00 ????? ????? ??? ????? 10011 11", fnmadd_s, R4);

    // RV64D instructions
    INSTPAT("??????? ????? ????? 011 ????? 00001 11", fld, I);
    INSTPAT("??????? ????? ????? 011 ????? 01001 11", fsd, S);
    INSTPAT("0000001 ????? ????? ??? ????? 10100 11", fadd_d, R);
    INSTPAT("0000101 ????? ????? ??? ????? 10100 11", fsub_d, R);
    INSTPAT("0001001 ????? ????? ??? ????? 10100 11", fmul_d, R);
    INSTPAT("0001101 ????? ????? ??? ????? 10100 11", fdiv_d, R);
    INSTPAT("0101101 00000 ????? ??? ????? 10100 11", fsqrt_d, R);
    INSTPAT("0010001 ????? ????? 000 ????? 10100 11", fsgnj_d, R);
    INSTPAT("0010001 ????? ????? 001 ????? 10100 11", fsgnjn_d, R);
    INSTPAT("0010001 ????? ????? 010 ????? 10100 11", fsgnjx_d, R);
    INSTPAT("0010101 ????? ????? 000 ????? 10100 11", fmin_d, R);
    INSTPAT("0010101 ????? ????? 001 ????? 10100 11", fmax_d, R);
    INSTPAT("1100001 00000 ????? ??? ????? 10100 11", fcvt_w_d, R);
    INSTPAT("1100001 00001 ????? ??? ????? 10100 11", fcvt_wu_d, R);
    INSTPAT("1100001 00010 ????? ??? ????? 10100 11", fcvt_l_d, R);
    INSTPAT("1100001 00011 ????? ??? ????? 10100 11", fcvt_lu_d, R);
    INSTPAT("1101001 00000 ????? ??? ????? 10100 11", fcvt_d_w, R);
    INSTPAT("1101001 00001 ????? ??? ????? 10100 11", fcvt_d_wu, R);
    INSTPAT("1101001 00010 ????? ??? ????? 10100 11", fcvt_d_l, R);
    INSTPAT("1101001 00011 ????? ??? ????? 10100 11", fcvt_d_lu, R);
    INSTPAT("0100000 00001 ????? ??? ????? 10100 11", fcvt_s_d, R);
    INSTPAT("0100001 00000 ????? ??? ????? 10100 11", fcvt_d_s, R);
    INSTPAT("1110001 00000 ????? 000 ????? 10100 11", fmv_x_d, R);
    INSTPAT("1111001 00000 ????? 000 ????? 10100 11", fmv_d_x, R);
    INSTPAT("1110001 00000 ????? 001 ????? 10100 11", fclass_d, R);
    INSTPAT("1010001 ????? ????? 010 ????? 10100 11", feq_d, R);
    INSTPAT("1010001 ????? ????? 001 ????? 10100 11", flt_d, R);
    INSTPAT("1010001 ????? ????? 000 ????? 10100 11", fle_d, R);
    INSTPAT("?????01 ????? ????? ??? ????? 10000 11", fmadd_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10001 11", fmsub_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10010 11", fnmsub_d, R4);
    INSTPAT("?????01 ????? ????? ??? ????? 10011 11", fnmadd_d, R4);

    // Invalid instructions
    INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv, N);

    INSTPAT_END();

    R(0) = 0; // reset $zero to 0
}

#undef INSTPAT_MATCH

#define INSTPAT_MATCH(s, name, type)                                           \
    {                                                                          \
        int rd = 0, rs1 = 0, rs2 = 0;                                          \
        uint64_t imm = 0;                                                      \
        decode_operand_16(s, &rd, &rs1, &rs2, &imm, concat(TYPE_, type));      \
        (s)->rd = rd;                                                          \
        (s)->rs1 = rs1;                                                        \
        (s)->rs2 = rs2;                                                        \
        (s)->imm = imm;                                                        \
        (s)->exec = exec_##name;                                               \
    }

void cpu_decode_16(rv_insn_t *s) {
    INSTPAT_START();

    // RV64C instructions
    INSTPAT("000 ?00000????? 01", c_nop, CI);
    INSTPAT("000 ??????????? 01", c_addi, CI);
    INSTPAT("001 ??????????? 01", c_addiw, CI);
    INSTPAT("010 ??????????? 01", c_li, CI);
    INSTPAT("011 ?00010????? 01", c_addi16sp, CI);
    INSTPAT("011 ??????????? 01", c_lui, CI);
    INSTPAT("100 ?00???????? 01", c_srli, CB);
    INSTPAT("100 ?01???????? 01", c_srai, CB);
    INSTPAT("100 ?10???????? 01", c_andi, CB);
    INSTPAT("100 011???00??? 01", c_sub, CA);
    INSTPAT("100 011???01??? 01", c_xor, CA);
    INSTPAT("100 011???10??? 01", c_or, CA);
    INSTPAT("100 011???11??? 01", c_and, CA);
    INSTPAT("100 111???00??? 01", c_subw, CA);
    INSTPAT("100 111???01??? 01", c_addw, CA);
    INSTPAT("101 ??????????? 01", c_j, CJ);
    INSTPAT("110 ??????????? 01", c_beqz, CB);
    INSTPAT("111 ??????????? 01", c_bnez, CB);
    INSTPAT("000 00000000000 00", c_inv, N);
    INSTPAT("000 ??????????? 00", c_addi4spn, CIW);
    INSTPAT("001 ??????????? 00", c_fld, CL);
    INSTPAT("010 ??????????? 00", c_lw, CL);
    INSTPAT("011 ??????????? 00", c_ld, CL);
    INSTPAT("101 ??????????? 00", c_fsd, CS);
    INSTPAT("110 ??????????? 00", c_sw, CS);
    INSTPAT("111 ??????????? 00", c_sd, CS);
    INSTPAT("000 ??????????? 10", c_slli, CI);
    INSTPAT("001 ??????????? 10", c_fldsp, CI);
    INSTPAT("010 ??????????? 10", c_lwsp, CI);
    INSTPAT("011 ??????????? 10", c_ldsp, CI);
    INSTPAT("100 0?????00000 10", c_jr, CR);
    INSTPAT("100 0?????????? 10", c_mv, CR);
    INSTPAT("100 10000000000 10", c_ebreak, CR);
    INSTPAT("100 1?????00000 10", c_jalr, CR);
    INSTPAT("100 1?????????? 10", c_add, CR);
    INSTPAT("101 ??????????? 10", c_fsdsp, CSS);
    INSTPAT("110 ??????????? 10", c_swsp, CSS);
    INSTPAT("111 ??????????? 10", c_sdsp, CSS);

    // Invalid instructions
    INSTPAT("??? ??????????? ??", inv, N);

    INSTPAT_END();

    R(0) = 0; // reset $zero to 0
}
